#!/usr/bin/env python3

import sys
import configparser
from pathlib import Path
import logging
import argparse

settings_map = [
    {
        "MapStreamSettings": ["mapStreamingTileWidth", "mapStreamingRadius"],
        "EngineSettings": ["storeImageOnKeyFrame"],
        "RelocalisationSettings": [
            "relocalisationBehaviour",
            "periodicRelocalisationRadius",
            "periodicRelocalisationAssociateRadius",
        ],
        "MapExpansionSettings": [
            "minimumDurationConstraintEnabled",
            "minimumDurationFromLastFrame",
            "distanceAndHeadingConstraintEnabled",
            "minimumDistanceMeters",
            "maximumHeadingDifferenceDegrees",
            "fractionNewPointsConstraintEnabled",
            "minimumFractionNewPoints",
            "combinationMode",
            "maxNumUnfrozenFrames",
            "enableExpansionFromPreviouslyTrackedFrame",
        ],
        "DynamicObjectSettings": [
            "enable",
            "timeWindowLength",
            "thresholdDetectDynamicObjects",
            "thresholdResumeSlam",
            "maxThresholdToRestartTracker",
            "minNumFramesDeadReckoning",
            "maxTimeToRestartTracker",
        ],
        "OptimisableMapSettings": [
            "mapExpansionSettings",
            "rackingBaOuterIterations",
            "trackingBaInnerIterations",
            "attemptLoopClosureOnKeyFrameAddition",
            "globalBundleAdjustOnLoopClosure",
            "runGlobalBundleAdjustmentEveryNKeyFrames",
            "rgbdInverseDepthSigma",
            "realtimePoseConstraintIntegrationWindowSize",
            "numFramesToMatchAgainst",
            "minMatchesToTrack",
            "minMatchFractionToTrack",
            "maximumLoopClosureRadius",
            "odometryConstraintWeight",
            "mode2D",
            "realtimePoseConstraintIntegration",
            "realtimePoseConstraintCovariancePropagation",
            "maxNumKeyFrames",
        ],
        "ExtractorSettings": [
            "featuresPerImage",
            "fastThreshold",
            "fastThresholdMin",
            "scoreMethod",
        ],
        "TrackerSettings": [
            "extractorSettings",
            "extrinsicsCalibration",
            "maxVelocity",
            "attemptTrackingWithoutRelocalisation",
            "runLocalBundleAdjustment",
            "rgbdConfidenceThreshold",
            "minValidDepth",
            "maxValidDepth",
            "usePointsWithoutDepth",
            "motionModelType",
            "visualRecoveryMode",
            "verticalConstraintWeight",
            "imuFusionWeight",
            "dynamicObjectsSettings",
            "stationaryImuInitialisation",
            "gravityMagnitude",
            "imuInitialiserSettings",
            "useDirectTracker",
            "useTracer",
            "directTrackingIterations",
            "numberOfDirectTrackerPyramidLevels",
            "maxTimeDifferenceForSynchronisedFrame",
            "poseConstraintInterpolationTimeout",
            "imuConstraintWeight",
        ],
    }
]

# Fields that require conversion from nanoseconds to seconds.
convert_fields = ["maxTimeDifferenceForSynchronisedFrame"]


def convert_settings(
    ini_settings_path: Path, output_path: Path, logger: logging.Logger
):

    in_parser = configparser.ConfigParser()
    in_parser.optionxform = str
    in_parser.read(ini_settings_path)

    logger.info(f"Beginning conversion of ini file: {ini_settings_path}...")

    out_parser = configparser.ConfigParser()
    out_parser.optionxform = str

    for settings in settings_map:
        for settings_name, elements in settings.items():
            for element in elements:
                for section in in_parser.sections():
                    if element in in_parser[section]:
                        if settings_name not in out_parser:
                            out_parser[settings_name] = {}
                        val = (
                            str(float(in_parser[section][element]) / 1e9)
                            if element in convert_fields
                            else in_parser[section][element]
                        )
                        out_parser[settings_name][element] = val
                        logger.debug(
                            f"Found {element} in ini file - moving to settings object: {settings_name}"
                        )

    with open(output_path, "w") as fp:
        out_parser.write(fp)


def main():

    parser = argparse.ArgumentParser(
        description="Script for converting KdVisual ini settings files generated by v2.6.0 to the new v3.0.0 format"
    )
    parser.add_argument(
        "settings_path", help="A path to where the settings ini to convert can be found"
    )
    parser.add_argument(
        "output_path", help="A path to where the converting ini file will be written"
    )
    parser.add_argument(
        "--verbose", "-v", help="Specifies a verbose output", action="store_true"
    )
    args = parser.parse_args()

    logger = logging.getLogger(__name__)
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    if not Path(args.settings_path).is_file():
        raise FileNotFoundError(f"Invalid ini settings path: {args.settings_path}")
    if Path(args.settings_path).suffix != ".ini":
        raise AttributeError(
            f"Settings path: {args.settings_path} must be an ini file."
        )

    if Path(args.output_path).is_file():
        logger.warning(f"A settings path already exists at: {args.output_path}")

    convert_settings(args.settings_path, args.output_path, logger)

    logger.info(f"Converted ini file written to: {args.output_path}")


if __name__ == "__main__":
    sys.exit(main())
